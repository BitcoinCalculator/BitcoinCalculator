<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Lump Sum vs DCA vs Hybrid — Rainbow Anchored Simulator</title>
<style>
 * { box-sizing: border-box; }
 body {
   font-family: "Helvetica Neue", Arial, sans-serif;
   background:#f9fafb;
   color:#1a1a1a;
   margin:0;
 }
 header {
   background:#111;
   color:#f9fafb;
   padding:1.6rem 1rem;
   text-align:center;
   box-shadow:0 2px 8px rgba(0,0,0,.3);
 }
 header h1 { margin:0 0 .25rem; font-size:2rem; }
 header p { margin:0; opacity:.9; }

 main { max-width:1100px; margin:2rem auto; padding:0 20px; }
 .calculator { background:#fff; padding:20px; border-radius:12px; box-shadow:0 2px 10px rgba(0,0,0,.08); }
 .grid { display:grid; grid-template-columns: repeat(auto-fit,minmax(240px,1fr)); gap:14px; }
 .form-group { display:flex; flex-direction:column; }
 label { font-weight:600; color:#333; margin-bottom:6px; }
 input[type="number"], input[type="text"], select {
   padding:10px; border:1px solid #ccc; border-radius:8px; font-size:14px; background:#fff;
 }
 .btn-row { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
 button {
   border:0; padding:12px 16px; border-radius:8px; cursor:pointer; font-size:15px; font-weight:700;
 }
 .btn-primary { background:#f7931a; color:#fff; width:100%; margin-top:8px; }
 .btn-primary:hover { background:#e07c12; }
 .btn-secondary { background:#007bff; color:#fff; }
 .btn-secondary:hover { background:#0056b3; }
 .btn-muted { background:#6c757d; color:#fff; }
 .btn-muted:hover { background:#5a6268; }
 .small { font-size:12px; color:#666; }
 #result, #error { margin-top:16px; }
 #result { display:none; background:#e9ecef; padding:14px; border-radius:8px; }
 #error { color:#c62828; }
 #chartContainer { display:none; margin-top:20px; }
 canvas { max-width:100%; }
 table { width:100%; border-collapse:collapse; margin-top:18px; background:#fff; }
 th, td { text-align:right; padding:8px; border-bottom:1px solid #eee; }
 th { background:#f8f9fa; position:sticky; top:0; }
 td:first-child, th:first-child { text-align:left; }
 .note { font-size:13px; color:#666; margin-top:6px; }
 footer { text-align:center; padding:1.5rem; color:#666; margin-top:18px; }
 .tag { display:inline-block; padding:6px 8px; border-radius:6px; background:#fff3cd; color:#8a6d3b; margin-top:6px; font-weight:600; }
 .muted-box { background:#f8f9fa; padding:10px; border-radius:8px; margin-top:10px; }
 .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
 .switch { display:flex; align-items:center; gap:8px; }
</style>
</head>
<body>
 <header>
   <h1>Lump Sum vs DCA vs Hybrid — Rainbow Anchored Simulator</h1>
   <p>Simulation anchored to a clean rainbow (log-log / power-law) baseline + realistic cycles, decreasing volatility, and halving bumps.</p>
 </header>

 <main>
   <div class="calculator">
     <div class="grid">
       <div class="form-group">
         <label for="totalInvest">Total Money to Invest (USD)</label>
         <input type="number" id="totalInvest" min="1" step="1" value="12000">
         <div class="small">Same capital used for all 3 strategies for fair comparison.</div>
       </div>

       <div class="form-group">
         <label for="horizonYears">Investment Horizon (years)</label>
         <input type="number" id="horizonYears" min="1" max="30" step="1" value="8">
       </div>

       <div class="form-group">
         <label for="avgCagr">Average Long-Term CAGR (%)</label>
         <input type="number" id="avgCagr" min="0" max="200" step="0.1" value="25">
         <div class="small">Average trend to anchor the rainbow baseline (20–30% recommended).</div>
       </div>

       <div class="form-group">
         <label for="cycleAmp">Bull/Bear Cycle Amplitude (%)</label>
         <input type="number" id="cycleAmp" min="0" max="100" step="1" value="40">
         <div class="small">How strong cyclical deviations are around baseline (±40% default).</div>
       </div>

       <div class="form-group">
         <label for="volStart">Starting Annual Volatility (%)</label>
         <input type="number" id="volStart" min="1" max="400" step="1" value="120">
       </div>

       <div class="form-group">
         <label for="volEnd">Ending Annual Volatility (%)</label>
         <input type="number" id="volEnd" min="0" max="200" step="1" value="60">
       </div>

       <div class="form-group">
         <label for="startPriceOverride">Manual BTC Price Override (optional USD)</label>
         <input type="number" id="startPriceOverride" min="0" step="0.01" placeholder="Leave blank to use CoinGecko">
         <div class="small">If blank, current price is fetched from CoinGecko (fallback will be used if fetch fails).</div>
       </div>

       <div class="form-group">
         <label>Current BTC Price (fetched)</label>
         <div id="btcPriceDisplay" class="small">Fetching current price…</div>
       </div>
     </div>

     <div class="row" style="margin-top:10px;">
       <div style="flex:1">
         <div class="btn-row">
           <button class="btn-primary" id="calcBtn">Run Simulation</button>
           <button class="btn-muted" id="resetBtn">Reset</button>
         </div>
       </div>
       <div style="min-width:220px; text-align:right;">
         <div class="switch">
           <label for="showRainbow" class="small">Show Rainbow Band</label>
           <input type="checkbox" id="showRainbow" checked>
         </div>
       </div>
     </div>

     <div class="muted-box" style="margin-top:10px;">
       <div class="tag" id="scenarioTag">Rainbow baseline (log-log) • cycles ±40% • decreasing vol</div>
       <div class="small" style="margin-top:8px;">
         Model: baseline price = C * (t + T0)^p (power-law/log-log). We set C so price at t=0 equals current BTC price, and choose p so the baseline approx achieves the requested avg CAGR over the horizon. Monthly simulated returns are baseline drift + cycle + halving bump + noise (decreasing volatility).
       </div>
     </div>

     <div id="error"></div>
     <div id="result"></div>

     <div id="chartContainer">
       <canvas id="strategyChart"></canvas>
     </div>

     <div id="tableContainer"></div>
   </div>
 </main>

 <footer>
   <p>&copy; 2025 The Bitcoiner's Calculators</p>
 </footer>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script>
// === utilities ===
const el = id => document.getElementById(id);
const money = v => '$' + Number(v).toLocaleString(undefined,{maximumFractionDigits:0});
const COINGECKO = 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd';
const COINGECKO_TIMEOUT_MS = 3500; // short timeout to avoid long hangs
const FALLBACK_PRICE = 50000; // used if fetch fails (inform user)

// state
let livePrice = null;
let lastSim = null;
let chart = null;

// fetch current BTC price with timeout + fallback
function fetchPrice() {
  el('btcPriceDisplay').textContent = 'Fetching current price…';

  const fetchPromise = fetch(COINGECKO).then(r => r.json());
  const timeout = new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), COINGECKO_TIMEOUT_MS));

  Promise.race([fetchPromise, timeout])
    .then(data => {
      if (data && data.bitcoin && data.bitcoin.usd) {
        livePrice = Number(data.bitcoin.usd);
        el('btcPriceDisplay').textContent = money(livePrice) + ' per BTC (CoinGecko)';
      } else {
        throw new Error('unexpected response');
      }
    })
    .catch(err => {
      console.warn('CoinGecko fetch error:', err);
      livePrice = FALLBACK_PRICE;
      el('btcPriceDisplay').textContent = `Unable to fetch (CoinGecko). Using fallback ${money(FALLBACK_PRICE)} — or enter manual price.`;
    });
}

// Gaussian random
function randn() {
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
}

// build baseline
function buildBaselineParams(startPrice, months, avgCagr) {
  const T0 = 1;
  const M = Math.max(1, months);
  const clamped = Math.max(-0.99, avgCagr);
  const numerator = Math.log(Math.pow(1 + clamped, M / 12));
  const denominator = Math.log((M + T0) / T0);
  let p = denominator === 0 ? 0 : numerator / denominator;
  p = Math.max(-5, Math.min(5, p));
  const C = startPrice / Math.pow(T0, p);
  return { C, p, T0 };
}

/*
  simulatePath improvements:
  - operate in log-space with mean reversion toward the baseline
  - shocks are smoothed into multi-month ramps (rise + fall)
  - decreasing volatility preserved
  - halving bumps, cycles preserved
*/
function simulatePath({startPrice, months, avgCagr, cycleAmp, volStart, volEnd, cyclePeriodMonths=48}) {
  const params = buildBaselineParams(startPrice, months, avgCagr);
  const { C, p, T0 } = params;
  const baseline = m => C * Math.pow(m + T0, p);

  const basePrices = Array.from({length: months+1}, (_,m) => baseline(m));
  const bandFactor = 3;
  const bandUpper = basePrices.map(v => v*bandFactor);
  const bandLower = basePrices.map(v => Math.max(0.01, v/bandFactor));
  const ln = Math.log, exp = Math.exp;

  const prices = new Array(months+1);
  prices[0] = Math.max(0.01, startPrice);
  let X = ln(prices[0]);

  const baseTheta = 0.25;    // slower pull so rallies last longer
  const thetaBoost = 0.6;    // boosted reversion after shocks
  let activeRevertMonths = 0;

  const phase = Math.random() * Math.PI * 2;
  const halvingMonths = [];
  for (let k=1; k<=Math.ceil(months/48)+1; k++) halvingMonths.push(k*48);

  // --- Shock state (ramps instead of instant jumps) ---
  let shockActive = false;
  let shockTarget = null;
  let shockStrength = 0;
  let shockDirection = 1; // +1 up, -1 down

  const monthlyShockProb = 0.02;     // rarer
  const shockRamp = 3 + Math.floor(Math.random()*4);  // 3–6 months ramp
  const shockDecay = 4 + Math.floor(Math.random()*5); // 4–8 months decay

  function clampToBand(logPrice,m){
    const up = ln(bandUpper[m]), lo = ln(bandLower[m]);
    return Math.max(lo, Math.min(up, logPrice));
  }

  for (let m=1; m<=months; m++) {
    const lnBase_m = ln(Math.max(1e-9, basePrices[m]));
    const lnBase_m1 = ln(Math.max(1e-9, basePrices[m-1]));
    const baselineDrift = lnBase_m - lnBase_m1;

    // Cycle
    const cycleAnnual = cycleAmp * Math.sin(2*Math.PI*(m/cyclePeriodMonths)+phase);
    const cycleMonthly = Math.log(1 + cycleAnnual) / 12;

    // Halving bonus
    let halvingBonus = 0;
    for (const hm of halvingMonths) {
      const dist = Math.abs(m - hm);
      if (dist <= 6) {
        const peak = 0.08;
        halvingBonus += Math.log(1 + peak*Math.exp(-dist*dist/18)) / 12;
      }
    }

    // Volatility
    const tFrac = m / Math.max(1, months);
    const annVol = volStart*(1 - tFrac) + volEnd*tFrac;
    let monthlySigma = annVol / Math.sqrt(12);

    // Add **minimum wiggle** (avoid flatline)
    const minWiggle = 0.05 + Math.random()*0.10; // 5–15%
    monthlySigma = Math.max(monthlySigma, minWiggle);

    const theta = activeRevertMonths>0 ? thetaBoost : baseTheta;
    const eps = randn()*monthlySigma;

    let Xnext = X + theta*(lnBase_m - X) + baselineDrift + cycleMonthly + halvingBonus + eps;

    // --- Handle shocks (smooth ramp & fall) ---
    if (!shockActive && Math.random() < monthlyShockProb) {
      shockActive = true;
      shockDirection = Math.random() < 0.5 ? -1 : +1;
      shockStrength = 0.0;
      shockTarget = shockDirection > 0 ? ln(bandUpper[m]) : ln(bandLower[m]);
      activeRevertMonths = shockRamp + shockDecay;
    }

    if (shockActive) {
      if (shockStrength < 1.0) {
        // ramping up
        shockStrength += 1.0/shockRamp;
      } else {
        // decaying down
        shockStrength -= 1.0/shockDecay;
        if (shockStrength <= 0) {
          shockActive = false;
          shockStrength = 0;
        }
      }
      // blend baseline + shock target
      Xnext = (1-shockStrength)*Xnext + shockStrength*shockTarget;
    }

    const clamped = clampToBand(Xnext,m);
    X = clamped;
    if (activeRevertMonths>0) activeRevertMonths--;

    prices[m] = Math.max(0.01, exp(X));
  }

  return { prices, basePrices, params, halvingMonths, bandLower, bandUpper };
}
// strategies
function calcStrategies(prices, totalInvest, months) {
  const monthlyInstall = totalInvest / months;
  const btcLump = totalInvest / prices[0];
  let btcDca = 0; for (let m=0; m<months; m++) btcDca += (monthlyInstall / prices[m]);
  const half = totalInvest / 2;
  let btcHybrid = half / prices[0];
  const hybridMonthly = (totalInvest - half) / months;
  for (let m=0; m<months; m++) btcHybrid += (hybridMonthly / prices[m]);
  const lumpSeries = prices.map(p => btcLump * p);
  const dcaSeries = prices.map(p => btcDca * p);
  const hybridSeries = prices.map(p => btcHybrid * p);
  return { btcLump, btcDca, btcHybrid, lumpSeries, dcaSeries, hybridSeries };
}

// render chart helper
function renderChart(sim, showRainbow=true) {
  const ctx = document.getElementById('strategyChart').getContext('2d');
  if (chart) chart.destroy();

  // Build labels: every month has an entry, but we only display year labels for months that are multiples of 12.
  const currentYear = sim.currentYear || new Date().getFullYear();
  const totalMonths = sim.months;
  const labels = [];
  for (let m=0; m<=totalMonths; m++) {
    if (m % 12 === 0) labels.push(String(currentYear + (m/12)));
    else labels.push('');
  }

  // datasets
  const datasets = [
    {
      label: 'Lump Sum — Portfolio Value',
      data: sim.lumpSeries,
      borderWidth: 2,
      borderColor: '#2b7cff',
      backgroundColor: 'transparent',
      tension: 0.25,
      yAxisID: 'y'
    },
    {
      label: 'DCA — Portfolio Value',
      data: sim.dcaSeries,
      borderWidth: 2,
      borderColor: '#f7931a',
      backgroundColor: 'transparent',
      tension: 0.25,
      yAxisID: 'y'
    },
    {
      label: 'Hybrid — Portfolio Value',
      data: sim.hybridSeries,
      borderWidth: 2,
      borderColor: '#28a745',
      backgroundColor: 'transparent',
      tension: 0.25,
      yAxisID: 'y'
    },
    {
      label: 'BTC Price (simulation)',
      data: sim.prices,
      borderWidth: 1,
      borderColor: '#6c757d',
      backgroundColor: 'transparent',
      tension: 0.2,
      yAxisID: 'y1'
    }
  ];

  if (showRainbow) {
    const baseline = sim.basePrices;
    const bandFactor = 3;
    const upper = baseline.map(v => v * bandFactor);
    const lower = baseline.map(v => v / bandFactor);

    datasets.push({
      label: 'Rainbow Upper',
      data: upper,
      borderWidth: 0,
      borderColor: 'rgba(0,0,0,0)',
      backgroundColor: 'rgba(247,147,26,0.08)',
      fill: '+1', // fill downward toward the baseline dataset (ordering matters)
      yAxisID: 'y1'
    });
    datasets.push({
      label: 'Rainbow Baseline',
      data: baseline,
      borderWidth: 1,
      borderColor: 'rgba(247,147,26,0.35)',
      backgroundColor: 'transparent',
      tension: 0.1,
      yAxisID: 'y1'
    });
    datasets.push({
      label: 'Rainbow Lower',
      data: lower,
      borderWidth: 0,
      borderColor: 'rgba(0,0,0,0)',
      backgroundColor: 'rgba(43,124,255,0.04)',
      fill: '-1',
      yAxisID: 'y1'
    });
  }

  chart = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      responsive: true,
      interaction: { mode: 'index', intersect: false },
      scales: {
        y: {
          type: 'linear',
          position: 'left',
          ticks: { callback: v => '$' + Number(v).toLocaleString() }
        },
        y1: {
          type: 'linear',
          position: 'right',
          grid: { drawOnChartArea: false },
          ticks: { callback: v => '$' + Number(v).toLocaleString() }
        },
        x: {
          ticks: {
            callback: function(val, index) {
              // only show the tick label if it's a non-empty label (we prepared '' for intermediate months)
              const label = this.getLabelForValue(index);
              return label ? label : '';
            },
            maxRotation: 0,
            autoSkip: false
          }
        }
      },
      plugins: {
        legend: { position: 'bottom' },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const v = ctx.parsed.y;
              return `${ctx.dataset.label}: $${Number(v).toLocaleString()}`;
            }
          }
        }
      }
    }
  });
}

// render summary/table
function renderSummary(sim) {
  const end = sim.months;
  const lumpFinal = Math.round(sim.lumpSeries[end]);
  const dcaFinal = Math.round(sim.dcaSeries[end]);
  const hybridFinal = Math.round(sim.hybridSeries[end]);
  const html = `
    <div><strong>Total Invested (each strategy):</strong> <strong>${money(Math.round(sim.inputs.totalInvest))}</strong></div>
    <div style="margin-top:8px;"><strong>Final Value — Lump Sum:</strong> <strong>${money(lumpFinal)}</strong> (Holdings: ${sim.btcLump.toFixed(8)} BTC)</div>
    <div style="margin-top:6px;"><strong>Final Value — DCA:</strong> <strong>${money(dcaFinal)}</strong> (Holdings: ${sim.btcDca.toFixed(8)} BTC)</div>
    <div style="margin-top:6px;"><strong>Final Value — Hybrid:</strong> <strong>${money(hybridFinal)}</strong> (Holdings: ${sim.btcHybrid.toFixed(8)} BTC)</div>
    <div style="margin-top:10px; font-weight:bold; font-size:1.05em; background:yellow; padding:8px; border-radius:6px; text-align:center;">
      Winner: ${determineWinner(sim)}
    </div>
    <div class="small" style="margin-top:8px;">Note: baseline is a power-law / log-log fit anchored to the current price and average CAGR. The simulated path follows that baseline with cycles and reducing volatility. This is an educational model, not financial advice.</div>
  `;
  el('result').innerHTML = html;
  el('result').style.display = 'block';
}

function determineWinner(sim) {
  const end = sim.months;
  const arr = [
    { name:'Lump Sum', val: sim.lumpSeries[end] },
    { name:'DCA', val: sim.dcaSeries[end] },
    { name:'Hybrid', val: sim.hybridSeries[end] }
  ];
  arr.sort((a,b)=>b.val-a.val);
  const diff = Math.abs(arr[0].val - arr[1].val);
  return `${arr[0].name} by ${money(Math.round(diff))}`;
}

function renderTable(sim) {
  let html = `<table><thead><tr><th>Year</th><th>Lump Value ($)</th><th>DCA Value ($)</th><th>Hybrid Value ($)</th><th>Total Invested by Year ($)</th></tr></thead><tbody>`;
  for (let i=0; i<sim.years.length; i++) {
    html += `<tr><td>${sim.years[i]}</td><td>${money(sim.yearLump[i])}</td><td>${money(sim.yearDca[i])}</td><td>${money(sim.yearHybrid[i])}</td><td>${money(sim.investedYear[i])}</td></tr>`;
  }
  html += `</tbody></table>`;
  el('tableContainer').innerHTML = html;
}

// run simulation (UI entry)
function runSimulation() {
  el('error').textContent = '';
  el('result').style.display = 'none';
  el('tableContainer').innerHTML = '';
  if (chart) { chart.destroy(); chart = null; }

  const totalInvest = Math.max(0, Number(el('totalInvest').value || 0));
  const horizonYears = Math.max(1, Math.round(Number(el('horizonYears').value || 1)));
  const avgCagr = Math.max(-0.99, Number(el('avgCagr').value || 25) / 100);
  const cycleAmp = Math.max(0, Number(el('cycleAmp').value || 40) / 100);
  const volStart = Math.max(0.001, Number(el('volStart').value || 120) / 100);
  const volEnd = Math.max(0, Number(el('volEnd').value || 60) / 100);
  const manual = Number(el('startPriceOverride').value || 0);

  if (totalInvest <= 0) { el('error').textContent = 'Total investment must be > 0.'; return; }
  const months = horizonYears * 12;

  // ensure we have a start price
  if (!livePrice && !manual) { el('error').textContent = 'No current BTC price — allow CoinGecko or enter a manual price.'; return; }
  const startPrice = (manual > 0) ? manual : livePrice;

  const { prices, basePrices, params } = simulatePath({
    startPrice,
    months,
    avgCagr,
    cycleAmp,
    volStart,
    volEnd,
    cyclePeriodMonths: 48
  });

  const strat = calcStrategies(prices, totalInvest, months);

  // build year snapshots and year labels starting from current year at runtime
  const currentYear = new Date().getFullYear();
  const years = [];
  const yearLump = [];
  const yearDca = [];
  const yearHybrid = [];
  const investedYear = [];
  for (let y=0; y<=horizonYears; y++) {
    const m = Math.min(months, y*12);
    years.push(String(currentYear + y));
    yearLump.push(Math.round(strat.lumpSeries[m]));
    yearDca.push(Math.round(strat.dcaSeries[m]));
    yearHybrid.push(Math.round(strat.hybridSeries[m]));
    const investedSoFar = (y===0) ? 0 : Math.round((totalInvest / months) * Math.min(months, y*12));
    investedYear.push(investedSoFar);
  }

  lastSim = {
    inputs: { totalInvest, horizonYears, avgCagr, cycleAmp, volStart, volEnd, startPrice },
    months,
    prices, basePrices, params,
    btcLump: strat.btcLump, btcDca: strat.btcDca, btcHybrid: strat.btcHybrid,
    lumpSeries: strat.lumpSeries, dcaSeries: strat.dcaSeries, hybridSeries: strat.hybridSeries,
    years, yearLump, yearDca, yearHybrid, investedYear,
    currentYear
  };

  renderSummary(lastSim);
  renderTable(lastSim);
  renderChart(lastSim, document.getElementById('showRainbow').checked);
  el('chartContainer').style.display = 'block';
}

// wire events
el('calcBtn').addEventListener('click', (e) => { e.preventDefault(); runSimulation(); });
el('resetBtn').addEventListener('click', (e) => { e.preventDefault(); resetAll(); });
el('showRainbow').addEventListener('change', () => {
  if (lastSim) renderChart(lastSim, el('showRainbow').checked);
});

// reset defaults
function resetAll() {
  el('totalInvest').value = 12000;
  el('horizonYears').value = 8;
  el('avgCagr').value = 25;
  el('cycleAmp').value = 40;
  el('volStart').value = 120;
  el('volEnd').value = 60;
  el('startPriceOverride').value = '';
  el('result').style.display = 'none';
  el('tableContainer').innerHTML = '';
  el('chartContainer').style.display = 'none';
  el('error').textContent = '';
  if (chart) { chart.destroy(); chart = null; }
  lastSim = null;
}

// initial fetch + reset
fetchPrice();
resetAll();
</script>
</body>
</html>
